!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AdjList	graph.c	9;"	d	file:
BFS	graph.c	/^int BFS(adjListGraph_p adjGraph, int i)$/;"	f
BFSAdjList	graph.c	/^int BFSAdjList(adjListGraph_p adjGraph)$/;"	f
DFS	graph.c	/^int DFS(adjListGraph_p adjGraph, int i)$/;"	f
DFSAdjList	graph.c	/^int DFSAdjList(adjListGraph_p adjGraph)$/;"	f
Edge	graph.c	/^} Edge;$/;"	t	typeref:struct:_Edge	file:
ElemType	chainlist.h	/^typedef int ElemType;$/;"	t
ElemType	linearlist.h	/^typedef int ElemType;$/;"	t
ElemType	queue.h	/^typedef int ElemType;$/;"	t
ElemType	stack.h	/^typedef int ElemType;$/;"	t
ElemType	tree.h	/^typedef int ElemType;$/;"	t
FIB_MAXSIZE	Fibonacci.c	3;"	d	file:
FibonacciSearch	Fibonacci.c	/^int FibonacciSearch(int *data, int length, int searchValue)  $/;"	f
GetLocalFileLenth	curl.c	/^long GetLocalFileLenth(const char* fileName)$/;"	f
LEFTCHILD	sort.c	167;"	d	file:
MAX_SIZE	linearlist.h	4;"	d
MAX_VERTEX	graph.h	5;"	d
PARENT	sort.c	166;"	d	file:
Prim	graph.c	/^int Prim(adjListGraph_p adjGraph)$/;"	f
ProduceFib	Fibonacci.c	/^void ProduceFib(int *fib, int size)  $/;"	f
Queue	graph.c	/^} Queue;$/;"	t	typeref:struct:_queue	file:
RIGHTCHILD	sort.c	168;"	d	file:
STACK_SIZE	stack.c	98;"	d	file:
_Edge	graph.c	/^typedef struct _Edge {$/;"	s	file:
__CHAIN_LIST_	chainlist.h	2;"	d
__GRAPH__H	graph.h	2;"	d
__LINEAR_LIST_	linearlist.h	2;"	d
__QUEUE__H	queue.h	2;"	d
__STACH__H	stack.h	2;"	d
__TREE_H_	tree.h	2;"	d
__isEmptyQueue	queue.c	/^int __isEmptyQueue(queue_p queue)$/;"	f
__isFullQueue	queue.c	/^int __isFullQueue(queue_p queue)$/;"	f
_adjListGraph	graph.h	/^typedef struct _adjListGraph {$/;"	s
_edgeNode	graph.h	/^typedef struct _edgeNode {$/;"	s
_matrixGraph	graph.h	/^typedef struct _matrixGraph {$/;"	s
_merge_sort	sort.c	/^int _merge_sort(int *array, int start, int end, int *temp)$/;"	f
_node	chainlist.h	/^typedef struct _node {$/;"	s
_queue	graph.c	/^typedef struct _queue {$/;"	s	file:
_queue	queue.h	/^typedef struct _queue {$/;"	s
_sqList	linearlist.h	/^typedef struct _sqList {$/;"	s
_stack	stack.h	/^typedef struct _stack {$/;"	s
_tmain	curl.c	/^int _tmain(int argc, _TCHAR* argv[])$/;"	f
_treeNode	tree.h	/^typedef struct _treeNode {$/;"	s
_vertexGraph	graph.h	/^typedef struct _vertexGraph {$/;"	s
addList	linearlist.c	/^int addList(sqList_p list, ElemType value, int i)$/;"	f
addListOfHead	chainlist.c	/^int addListOfHead(chainNode_p head, ElemType value)$/;"	f
addListOfTail	chainlist.c	/^int addListOfTail(chainNode_p head, ElemType value)$/;"	f
addListOfTail	linearlist.c	/^int addListOfTail(sqList_p list, ElemType value)$/;"	f
adjListGraph_p	graph.h	/^} adjListGraph_s, *adjListGraph_p;$/;"	t	typeref:struct:_adjListGraph
adjListGraph_s	graph.h	/^} adjListGraph_s, *adjListGraph_p;$/;"	t	typeref:struct:_adjListGraph
assetsManagerProgressFunc	curl.c	/^int assetsManagerProgressFunc(void *ptr, double totalToDownload, double nowDownloaded, double totalToUpLoad, double nowUpLoaded)$/;"	f
base	queue.h	/^	ElemType *base;$/;"	m	struct:_queue
base	stack.h	/^	ElemType *base;$/;"	m	struct:_stack
chainNode_p	chainlist.h	/^}chainNode_s, *chainNode_p;$/;"	t	typeref:struct:_node
chainNode_s	chainlist.h	/^}chainNode_s, *chainNode_p;$/;"	t	typeref:struct:_node
clearList	linearlist.c	/^int clearList(sqList_p list)$/;"	f
countTreeNode	tree.c	/^int countTreeNode(treeNode_p bTree)$/;"	f
crateAdjListGraph	graph.c	/^int crateAdjListGraph(adjListGraph_p adjGraph)$/;"	f
crateMatrixGraph	graph.c	/^int crateMatrixGraph(matrixGraph *graph)$/;"	f
crateOrtListGraph	graph.c	/^int crateOrtListGraph(ortListGraph_p ortGraph)$/;"	f
createQueue	queue.c	/^int createQueue(queue_s *queue, int queueSize)$/;"	f
createStack	stack.c	/^int createStack(stack_p stack, int stackSize)$/;"	f
createTreeNode	tree.c	/^int createTreeNode(treeNode_s **bTree, ElemType value)$/;"	f
data	chainlist.h	/^	ElemType data;$/;"	m	struct:_node
data	linearlist.h	/^	ElemType data[MAX_SIZE];$/;"	m	struct:_sqList
deleteList	chainlist.c	/^int deleteList(chainNode_p head, int i)$/;"	f
deleteList	linearlist.c	/^int deleteList(sqList_p list, int i, ElemType *e)$/;"	f
deleteListOfTail	chainlist.c	/^int deleteListOfTail(chainNode_p head)$/;"	f
deleteTreeNode	tree.c	/^int deleteTreeNode(treeNode_s **bTree, ElemType value)$/;"	f
dequeue	graph.c	/^int dequeue(Queue *q, vertexType *v) $/;"	f
downLoad	curl.c	/^bool downLoad(void *_curl, std::string _packageUrl, std::string _storagePath, std::string fileName )$/;"	f
downLoadPackage	curl.c	/^static size_t downLoadPackage(void *ptr, size_t size, size_t nmemb, void *userdata)$/;"	f	file:
edgeNode_p	graph.h	/^} edgeNode_s, *edgeNode_p;$/;"	t	typeref:struct:_edgeNode
edgeNode_s	graph.h	/^} edgeNode_s, *edgeNode_p;$/;"	t	typeref:struct:_edgeNode
end	graph.c	/^	vertexType end; \/*结束顶点*\/$/;"	m	struct:_Edge	file:
enqueue	graph.c	/^int enqueue(Queue *q, vertexType v) $/;"	f
exchange	sort.c	/^int exchange(int *array, int p1, int p2)$/;"	f
findTreeNode	tree.c	/^treeNode_p findTreeNode(treeNode_p bTree, ElemType value)$/;"	f
fistNode	graph.h	/^	edgeNode_p fistNode;$/;"	m	struct:_vertexGraph
freeList	chainlist.c	/^int freeList(chainNode_p head)$/;"	f
freeList	linearlist.c	/^int freeList(sqList_p list)$/;"	f
front	queue.h	/^	int front;$/;"	m	struct:_queue
getDownloadFileLenth	curl.c	/^long getDownloadFileLenth(const char *url){$/;"	f
getElemList	linearlist.c	/^int getElemList(sqList_p list, int i, ElemType *e)$/;"	f
getValueList	chainlist.c	/^int getValueList(chainNode_p head, ElemType *value, int i)$/;"	f
graph	graph.h	/^	vertexGraph graph;$/;"	m	struct:_adjListGraph
head	graph.c	/^	int head, tail;$/;"	m	struct:_queue	file:
heap_sort	sort.c	/^int heap_sort(int *array, int length)$/;"	f
initList	chainlist.c	/^int initList(chainNode_s **head)$/;"	f
initList	linearlist.c	/^int initList(sqList_s **list)$/;"	f
insertList	chainlist.c	/^int insertList(chainNode_p head, ElemType value, int i)$/;"	f
insertTreeNode	tree.c	/^int insertTreeNode(treeNode_s **bTree, ElemType value)$/;"	f
insert_sort	sort.c	/^int insert_sort(int *array, int length)$/;"	f
isEmptyList	linearlist.c	/^int isEmptyList(sqList_p list)$/;"	f
isEmptyQueue	graph.c	/^int isEmptyQueue(Queue *q)$/;"	f
isEmptyQueue	queue.c	/^int isEmptyQueue(queue_p queue)$/;"	f
isEmptyStack	stack.c	/^int isEmptyStack(stack_p stack)$/;"	f
isFullList	linearlist.c	/^int isFullList(sqList_p list)$/;"	f
isFullQueue	graph.c	/^int isFullQueue(Queue *q)$/;"	f
isFullQueue	queue.c	/^int isFullQueue(queue_p queue)$/;"	f
isFullStack	stack.c	/^int isFullStack(stack_p stack)$/;"	f
isLengthStack	stack.c	/^int isLengthStack(stack_p stack)$/;"	f
lChild	tree.h	/^	struct _treeNode *lChild;$/;"	m	struct:_treeNode	typeref:struct:_treeNode::_treeNode
length	linearlist.h	/^	int length;$/;"	m	struct:_sqList
lengthList	chainlist.c	/^int lengthList(chainNode_p head)$/;"	f
lengthList	linearlist.c	/^int lengthList(sqList_p list)$/;"	f
locateGraph	graph.c	/^int locateGraph(adjListGraph_p adjGraph, vertexType c)$/;"	f
locateGraph	graph.c	/^int locateGraph(matrixGraph *graph, vertexType c)$/;"	f
locateGraph	graph.c	/^int locateGraph(ortListGraph_p adjGraph, vertexType c)$/;"	f
main	Fibonacci.c	/^int main()  $/;"	f
main	chainListReverse.c	/^int main()$/;"	f
main	chainlist.c	/^int main()$/;"	f
main	graph.c	/^int main()$/;"	f
main	linearlist.c	/^int main()$/;"	f
main	queue.c	/^int main()$/;"	f
main	sort.c	/^int main(int argc, char **argv)$/;"	f
main	stack.c	/^int main(int argc, char **argv)$/;"	f
main	tree.c	/^int main()$/;"	f
martix	graph.h	/^	int martix[MAX_VERTEX][MAX_VERTEX];	$/;"	m	struct:_matrixGraph
matrixGraph	graph.h	/^}matrixGraph;$/;"	t	typeref:struct:_matrixGraph
maxHeapify	sort.c	/^int maxHeapify(int *array, int pos, int length)$/;"	f
mergeSort	sort.c	/^int mergeSort(int *array, int length)$/;"	f
merge_array	sort.c	/^int merge_array(int *array, int start, int middle, int end, int *temp)$/;"	f
next	chainListReverse.c	/^	struct node *next;$/;"	m	struct:node	typeref:struct:node::node	file:
next	chainlist.h	/^	struct _node *next;$/;"	m	struct:_node	typeref:struct:_node::_node
next	graph.h	/^	struct _edgeNode *next;$/;"	m	struct:_edgeNode	typeref:struct:_edgeNode::_edgeNode
node	chainListReverse.c	/^struct node {$/;"	s	file:
numEages	graph.h	/^	int numEages, numVertex;$/;"	m	struct:_matrixGraph
numEdges	graph.h	/^	int numEdges, numVertex; \/*顶点数与边数*\/$/;"	m	struct:_adjListGraph
numVertex	graph.h	/^	int numEages, numVertex;$/;"	m	struct:_matrixGraph
numVertex	graph.h	/^	int numEdges, numVertex; \/*顶点数与边数*\/$/;"	m	struct:_adjListGraph
parent	tree.h	/^	struct _treeNode *parent;$/;"	m	struct:_treeNode	typeref:struct:_treeNode::_treeNode
popQueue	queue.c	/^int popQueue(queue_p queue, ElemType *value)$/;"	f
popStack	stack.c	/^int popStack(stack_p stack, ElemType *value)$/;"	f
printfGraph	graph.c	/^int printfGraph(adjListGraph_p adjGraph)$/;"	f
printfGraph	graph.c	/^int printfGraph(matrixGraph *graph)$/;"	f
printfGraph	graph.c	/^int printfGraph(ortListGraph_p adjGraph)$/;"	f
printfList	chainListReverse.c	/^int printfList(struct node* head)$/;"	f
printfList	chainlist.c	/^int printfList(chainNode_p head)$/;"	f
printfList	linearlist.c	/^int printfList(sqList_p list)$/;"	f
printfStack	stack.c	/^int printfStack(stack_p stack)$/;"	f
printfTree	tree.c	/^int printfTree(treeNode_p bTree)$/;"	f
pushQueue	queue.c	/^int pushQueue(queue_p queue, ElemType value)$/;"	f
pushStack	stack.c	/^int pushStack(stack_p stack, ElemType value)$/;"	f
queueLock	queue.h	/^	pthread_mutex_t queueLock;$/;"	m	struct:_queue
queueSize	queue.h	/^	int queueSize;$/;"	m	struct:_queue
queue_p	queue.h	/^}queue_s, *queue_p;$/;"	t	typeref:struct:_queue
queue_s	queue.h	/^}queue_s, *queue_p;$/;"	t	typeref:struct:_queue
quick_sort	sort.c	/^int quick_sort(int *array, int start, int end)$/;"	f
rChild	tree.h	/^	struct _treeNode *rChild;$/;"	m	struct:_treeNode	typeref:struct:_treeNode::_treeNode
rear	queue.h	/^	int rear;$/;"	m	struct:_queue
reverse	chainListReverse.c	/^int reverse(struct node **head) $/;"	f
reverse2	chainListReverse.c	/^struct node* reverse2(struct node* head)$/;"	f
shell_sort	sort.c	/^int shell_sort(int *array, int length, int step)$/;"	f
sqList_p	linearlist.h	/^}sqList_s, *sqList_p;$/;"	t	typeref:struct:_sqList
sqList_s	linearlist.h	/^}sqList_s, *sqList_p;$/;"	t	typeref:struct:_sqList
st	graph.c	/^	vertexType st; \/*开始顶点*\/$/;"	m	struct:_Edge	file:
stackSize	stack.h	/^	int stackSize;$/;"	m	struct:_stack
stack_p	stack.h	/^} stack_s, *stack_p;$/;"	t	typeref:struct:_stack
stack_s	stack.h	/^} stack_s, *stack_p;$/;"	t	typeref:struct:_stack
std	curl.c	/^using namespace std;$/;"	v
tail	graph.c	/^	int head, tail;$/;"	m	struct:_queue	file:
top	stack.h	/^	ElemType *top;$/;"	m	struct:_stack
treeNode_p	tree.h	/^}treeNode_s, *treeNode_p;$/;"	t	typeref:struct:_treeNode
treeNode_s	tree.h	/^}treeNode_s, *treeNode_p;$/;"	t	typeref:struct:_treeNode
v	chainListReverse.c	/^	int v;$/;"	m	struct:node	file:
value	tree.h	/^	ElemType value;$/;"	m	struct:_treeNode
vertex	graph.c	/^	vertexType vertex[MAX_VERTEX];$/;"	m	struct:_queue	file:
vertex	graph.h	/^	vertexType vertex; \/*顶点*\/$/;"	m	struct:_edgeNode
vertex	graph.h	/^	vertexType vertex;$/;"	m	struct:_vertexGraph
vertex	graph.h	/^	vertexType vertex[MAX_VERTEX];$/;"	m	struct:_matrixGraph
vertexGraph	graph.h	/^}vertexGraph[MAX_VERTEX], vertexGraph_s;$/;"	t	typeref:struct:_vertexGraph
vertexGraph_s	graph.h	/^}vertexGraph[MAX_VERTEX], vertexGraph_s;$/;"	t	typeref:struct:_vertexGraph
vertexType	graph.h	/^typedef char  vertexType; \/*顶点类型*\/$/;"	t
visited	graph.c	/^int visited[MAX_VERTEX]; \/*遍历标记*\/$/;"	v
weight	graph.c	/^	weightType weight; \/*权重*\/$/;"	m	struct:_Edge	file:
weight	graph.h	/^	weightType weight; \/*权重*\/$/;"	m	struct:_edgeNode
weightType	graph.h	/^typedef int  weightType;$/;"	t
